#include <iostream>
using namespace std;

int main() {
    int n, k, i;
    int sum = 0;

    // n -> 공의 개수
    // k -> 팀의 개수
    cin >> n >> k;
    // 공의 최소 개수 계산 
    // 공은 전부 다 다른 개수로 분배 되어야 하기 떄문에 팀의 개수가 3이라면 공의 개수는 1,2,3 개로 분배되어야 함
    // 즉, 공의 최소 개수는 팀이 k개일 경우 공이 각각 1,2,3,4.....k 까지 분배 되어야 하므로
    // 1~k(팀의 개수)를 모두 더한값이 됨
    for (i = 1; i <= k; i++) 
    { 
        sum += i;
    }
    int remainedBall = n - sum;

    // 만약 전체 공의 개수가 팀별로 다른 개수의 공을 나누기 위한 최소 개수보다 작을경우
    if (remainedBall < 0)
    {

        cout << -1;
    }
    //
    else 
    {
        // 문제에서 공은 "가장 많이 담긴 바구니와 가장 적게 담긴 바구니의 공의 개수 차이가 최소가 되도록 담을 것이다" 라고하였다
        // 공의개수 n이 6이고 팀의 개수 k 가 3일경우를 살펴보자
        // 1)
        //     O        OO       OOO
        //   1번팀     2번팀     3번팀
        //
        // 여기서 공이 1개가 추가로 들어올 경우 3번팀에 추가 할 수밖에 없다 (팀별로 공의 개수가 겹치지 않아야 하므로)
        // 2)     
        //     O        OO       OOOO
        //   1번팀     2번팀     3번팀
        //
        // 공이 1개 더 추가될 경우 가능한 경우는 2번팀에 추가해야한다
        // 3)     
        //     O        OOO      OOOO
        //   1번팀     2번팀     3번팀
        //
        // 공이 1개 더 추가될 경우 공의 개수 차이가 최소가 되야 하므로 1번팀에 추가해야한다
        // 4)     
        //     OO        OOO      OOOO
        //   1번팀     2번팀     3번팀
        //
        // 위의 케이스를 반복하다보면, 공의 최대 차이 개수는 k 또는 k-1 인걸 확인 할 수 있다
        // 바구니별로 모두 연속적인 숫자로 담겨있는 경우가 k-1이고, 
        // 바구니별로 1 초과 차이가 나는경우가 k 인걸 알 수 있다.
        // remainedBall 변수에는 바구니별로 다르게 담기위한 최소 공의 개수를 빼주었으므로
        // remainedBall을 팀의 개수로 나누었을 때 나머지로 최소 공의 개수 판단 가능

        // 볼의 개수가 연속적인 
        if (remainedBall % k == 0)
        {
            cout << k - 1;
        }
        else if (remainedBall % k != 0)
        {
            cout << k;
        }
    }
}
