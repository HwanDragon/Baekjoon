
// 문제 이해
// 1. 첫째줄에 전체 컴퓨터의 개수 N (N < 10,000 의 자연수), 총 신뢰 개수 M (M <= 100,000)를 입력받음
// 2. 신뢰의 경우 A B 형식으로 들어오며 "A가 B를 신뢰한다(B를 해킹하면 A를 해킹할 수 있음)"

// 백준 입력
//    ----
//    5 4
//    ----
// 1) 3 1
// 2) 3 2
// 3) 4 3
// 4) 5 3
//    ----

// 위의 경우를 살펴보면 전체 컴퓨터의 개수는 5개 이고, 신뢰 개수는 4개이다.
// 1) 의 경우 "3 1"이고, 즉, 1번 컴퓨터를 해킹하면 3번 컴퓨터도 해킹이 가능하다는 이야기이다
// 2) 의 경우 "3 2"이고, 즉, 2번 컴퓨터를 해킹하면 3번 컴퓨터도 해킹이 가능하다는 이야기이다
// 3) 의 경우 "4 3"이고, 즉, 3번 컴퓨터를 해킹하면 4번 컴퓨터도 해킹이 가능하다는 이야기이다
// 4) 의 경우 "5 3"이고, 즉, 3번 컴퓨터를 해킹하면 5번 컴퓨터도 해킹이 가능하다는 이야기이다
// 
// 위의 경우를 살펴보면 아래와 같은 방향성이 있는 그래프를 나타낸다는것을 알 수 있다.
// 
// 
//  5   <-  3  <-  1
//  4   <-     <-  2
//      
// (1번을 해킹하면 3번도 해킹이 가능하고, 3번을 해킹하면 4, 5번이 해킹이 가능함)
// (2번을 해킹하면 3번도 해킹이 가능하고, 3번을 해킹하면 4, 5번이 해킹이 가능함)
// (3번을 해킹하면 4,5번 해킹이 가능함)
// (4번을 해킹하면 4번만 해킹이 가능함)
// (5번을 해킹하면 5번만 해킹이 가능함)

// 즉 dfs를 이용하여 그래프를 탐색하고 노드들을 탐색할 때마다 해킹할 수 있는 컴퓨터 개수를 새면 됨


#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

vector<int> v[10001];
int visited[10001];
int cnt;

void dfs(int x) {
    // x 번째 노드에 방문했으면 빠져나온다
    if (visited[x]) return;

    visited[x] = true;  // 방문하지 않았으면 방문했다고 변경
    cnt++;  // 해킹할 수 있는 컴퓨터의 개수를 1 증가시킴
    // x번째 컴퓨터를 해킹하면 추가로 해킹이 가능한 다른 컴퓨터가 있는지 검사
    for (int i = 0; i < v[x].size(); i++) {
        // 신뢰할 수 있는 다른 컴퓨터가 있으면 다시 dfs 탐색 시작
        int y = v[x][i];
        dfs(y);
    }
}

int main(int argc, const char* argv[]) {
    // 사용자 입력받음
    int N, M;
    cin >> N >> M;
    int a, b;
    for (int i = 0; i < M; i++) {
        cin >> a >> b;
        v[b].push_back(a);
    }

    
    int depth[10001]; //탐색 결과 저장

    // dfs 탐색
    for (int i = 1; i <= N; i++) {
        memset(visited, 0, sizeof(visited));
        cnt = 0;
        dfs(i);
        depth[i] = cnt;
    }

    // 탐색 결과에서 최대값 검색
    int max = 0;
    for (int i = 1; i <= N; i++) {
        if (max < depth[i])
            max = depth[i];
    }

    // 결과 출력
    for (int i = 0; i <= N; i++) {
        if (max == depth[i])
            cout << i << ' ';
    }


    return 0;
}
